#（你需要知道的优化浏览器的方法）
  
  （在过去的几年中,有大量的前端功能性能的责任已经从浏览器开发人员。而不是假定“浏览器会更快运行我的代码”,有一点“我需要改变代码浏览器更快。”）
# will-change
(规范，说明)
  
  （允许作者提前告知浏览器的默认样式，那他们可能会做出一个元素。它允许对浏览器默认样式的优化如何提前处理因素，在动画实际开始之前，为准备动画所执行的潜在昂贵的工作。）
  
  （换言之，除了使用动画和变换，你要在动画和变换这些变化前告诉浏览器）
  
  ```css
.element {
  will-change: transform;
}
.element:hover {
  transform: rotateY(180deg);
}
  
  ```
  
  （Sara Soueidan有一篇更深入的文章，我们有一个年鉴参考。）
#contain
(规范，说明)
  
  （包含属性允许作者表明一个元素及其内容,尽可能独立于其他文档树。这里允许浏览器在呈现页面时恰当的使用contain获得更强的优化，并允许作者相信，他们的页面不会因为缓存路径的改变而发生变化。）
  
  （换言之，换句话说,如果你知道某些事情和元素及其后代,你应该告诉浏览器它可以优化这些事情。例如……contain:size;—“这确保包含元素可以无需检查它的后代。”）
###Example(例子)：
> 例子
  
  (Michael Scharnagl 最近写了一篇文章：)
  
  （就像一个内联框架，这个边界建立一个新的布局根,确保DOM改变父文档的子树不会触发回流。）
#Responsive Images（响应式图片）
  
  （也许最明显的“你告诉浏览器”场景是响应图像,特别是大小属性。浏览器将计算每个图像的实际像素密度从指定呈现宽描述符和指定的大小的大小属性。它可以选择任何给定的资源根据用户的屏幕的像素密度,缩放级别,可能还有其他因素,如用户的网络环境。）
Spec(规范，说明)
  
  （浏览器将计算每个图像的有效像素密度从指定呈现宽描述符和指定呈现的尺寸属性。它可以选择任何给定的资源根据用户的屏幕的像素密度,缩放级别,可能还有其他因素,如用户的网络环境。）
  
  （这里有一个例子的规范,你给浏览器尽可能使用:）
  > 例子
  
  （如果浏览器窗口小于30 em,我会显示图像宽100vw。）
  
  （如果浏览器窗口在30 em和50 em之间,我会显示图像宽50vw。）
  
  （否则(如果它更大),我将显示图像宽为(33vw - 100 px)。）
  
  （然后需要匹配你实际做的CSS。希望它是相当准确的,所以浏览器优化与现实相匹配。）
#A Brave New World（一个美好的新世界）
  
  （我提到这些事情不是因为我认为你需要立即跑出去开始使用所有这些。更多的焦点（如果可以）趋势，在前端性能特征的浏览器问更多的作者。）
  
  （我认为浏览器厂商和规范作者会说:“你想要的性能。我们只有这么多。有些事情我们不知道,但你知道。我们将尽一切没有它们,但是如果你告诉我们我们可以做得更多。”）
  
  （你说呢？）

